'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _mimeTypes = require('@paulcbetts/mime-types');

var _mimeTypes2 = _interopRequireDefault(_mimeTypes);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _zlib = require('zlib');

var _zlib2 = _interopRequireDefault(_zlib);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _promise = require('./promise');

var _forAllFiles = require('./for-all-files');

var _compileCache = require('./compile-cache');

var _compileCache2 = _interopRequireDefault(_compileCache);

var _fileChangeCache = require('./file-change-cache');

var _fileChangeCache2 = _interopRequireDefault(_fileChangeCache);

var _readOnlyCompiler = require('./read-only-compiler');

var _readOnlyCompiler2 = _interopRequireDefault(_readOnlyCompiler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var d = require('debug-electron')('electron-compile:compiler-host');

require('./rig-mime-types').init();

// This isn't even my
var finalForms = {
  'text/javascript': true,
  'application/javascript': true,
  'text/html': true,
  'text/css': true,
  'image/svg+xml': true,
  'application/json': true
};

/**
 * This class is the top-level class that encapsulates all of the logic of
 * compiling and caching application code. If you're looking for a "Main class",
 * this is it.
 *
 * This class can be created directly but it is usually created via the methods
 * in config-parser, which will among other things, set up the compiler options
 * given a project root.
 *
 * CompilerHost is also the top-level class that knows how to serialize all of the
 * information necessary to recreate itself, either as a development host (i.e.
 * will allow cache misses and actual compilation), or as a read-only version of
 * itself for production.
 */

var CompilerHost = function () {
  /**
   * Creates an instance of CompilerHost. You probably want to use the methods
   * in config-parser for development, or {@link createReadonlyFromConfiguration}
   * for production instead.
   *
   * @param  {string} rootCacheDir  The root directory to use for the cache
   *
   * @param  {Object} compilers  an Object whose keys are input MIME types and
   *                             whose values are instances of CompilerBase. Create
   *                             this via the {@link createCompilers} method in
   *                             config-parser.
   *
   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is
   *                                             optionally pre-loaded.
   *
   * @param  {boolean} readOnlyMode  If True, cache misses will fail and
   *                                 compilation will not be attempted.
   *
   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
   *                                         which doesn't have a matching compiler,
   *                                         this compiler will be used instead. If
   *                                         null, will fail compilation. A good
   *                                         alternate fallback is the compiler for
   *                                         'text/plain', which is guaranteed to be
   *                                         present.
   */
  function CompilerHost(rootCacheDir, compilers, fileChangeCache, readOnlyMode) {
    var fallbackCompiler = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    (0, _classCallCheck3.default)(this, CompilerHost);

    var compilersByMimeType = (0, _assign2.default)({}, compilers);
    (0, _assign2.default)(this, { rootCacheDir: rootCacheDir, compilersByMimeType: compilersByMimeType, fileChangeCache: fileChangeCache, readOnlyMode: readOnlyMode, fallbackCompiler: fallbackCompiler });
    this.appRoot = this.fileChangeCache.appRoot;

    this.cachesForCompilers = (0, _keys2.default)(compilersByMimeType).reduce(function (acc, x) {
      var compiler = compilersByMimeType[x];
      if (acc.has(compiler)) return acc;

      acc.set(compiler, _compileCache2.default.createFromCompiler(rootCacheDir, compiler, fileChangeCache, readOnlyMode));
      return acc;
    }, new _map2.default());
  }

  /**
   * Creates a production-mode CompilerHost from the previously saved
   * configuration
   *
   * @param  {string} rootCacheDir  The root directory to use for the cache. This
   *                                cache must have cache information saved via
   *                                {@link saveConfiguration}
   *
   * @param  {string} appRoot  The top-level directory for your application (i.e.
   *                           the one which has your package.json).
   *
   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
   *                                         which doesn't have a matching compiler,
   *                                         this compiler will be used instead. If
   *                                         null, will fail compilation. A good
   *                                         alternate fallback is the compiler for
   *                                         'text/plain', which is guaranteed to be
   *                                         present.
   *
   * @return {Promise<CompilerHost>}  A read-only CompilerHost
   */


  (0, _createClass3.default)(CompilerHost, [{
    key: 'saveConfiguration',


    /**
     * Saves the current compiler configuration to a file that
     * {@link createReadonlyFromConfiguration} can use to recreate the current
     * compiler environment
     *
     * @return {Promise}  Completion
     */
    value: function () {
      var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
        var _this = this;

        var serializedCompilerOpts, info, target, buf;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                serializedCompilerOpts = (0, _keys2.default)(this.compilersByMimeType).reduce(function (acc, x) {
                  var compiler = _this.compilersByMimeType[x];
                  var Klass = (0, _getPrototypeOf2.default)(compiler).constructor;

                  var val = {
                    name: Klass.name,
                    inputMimeTypes: Klass.getInputMimeTypes(),
                    compilerOptions: compiler.compilerOptions,
                    compilerVersion: compiler.getCompilerVersion()
                  };

                  acc[x] = val;
                  return acc;
                }, {});
                info = {
                  fileChangeCache: this.fileChangeCache.getSavedData(),
                  compilers: serializedCompilerOpts
                };
                target = _path2.default.join(this.rootCacheDir, 'compiler-info.json.gz');
                _context.next = 5;
                return _promise.pzlib.gzip(new Buffer((0, _stringify2.default)(info)));

              case 5:
                buf = _context.sent;
                _context.next = 8;
                return _promise.pfs.writeFile(target, buf);

              case 8:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function saveConfiguration() {
        return _ref.apply(this, arguments);
      }

      return saveConfiguration;
    }()

    /**
     * Compiles a file and returns the compiled result.
     *
     * @param  {string} filePath  The path to the file to compile
     *
     * @return {Promise<object>}  An Object with the compiled result
     *
     * @property {Object} hashInfo  The hash information returned from getHashForPath
     * @property {string} code  The source code if the file was a text file
     * @property {Buffer} binaryData  The file if it was a binary file
     * @property {string} mimeType  The MIME type saved in the cache.
     * @property {string[]} dependentFiles  The dependent files returned from
     *                                      compiling the file, if any.
     */

  }, {
    key: 'compile',
    value: function compile(filePath) {
      return this.readOnlyMode ? this.compileReadOnly(filePath) : this.fullCompile(filePath);
    }

    /**
     * Handles compilation in read-only mode
     *
     * @private
     */

  }, {
    key: 'compileReadOnly',
    value: function () {
      var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(filePath) {
        var type, hashInfo, compiler, _ref3, _code, _binaryData, _mimeType, cache, _ref4, code, binaryData, mimeType;

        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                // We guarantee that node_modules are always shipped directly
                type = _mimeTypes2.default.lookup(filePath);

                if (!_fileChangeCache2.default.isInNodeModules(filePath)) {
                  _context2.next = 7;
                  break;
                }

                _context2.t0 = type || 'application/javascript';
                _context2.next = 5;
                return _promise.pfs.readFile(filePath, 'utf8');

              case 5:
                _context2.t1 = _context2.sent;
                return _context2.abrupt('return', {
                  mimeType: _context2.t0,
                  code: _context2.t1
                });

              case 7:
                _context2.next = 9;
                return this.fileChangeCache.getHashForPath(filePath);

              case 9:
                hashInfo = _context2.sent;


                // NB: Here, we're basically only using the compiler here to find
                // the appropriate CompileCache
                compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

                if (compiler) {
                  _context2.next = 20;
                  break;
                }

                compiler = this.fallbackCompiler;

                _context2.next = 15;
                return compiler.get(filePath);

              case 15:
                _ref3 = _context2.sent;
                _code = _ref3.code;
                _binaryData = _ref3.binaryData;
                _mimeType = _ref3.mimeType;
                return _context2.abrupt('return', { code: _code || _binaryData, mimeType: _mimeType });

              case 20:
                cache = this.cachesForCompilers.get(compiler);
                _context2.next = 23;
                return cache.get(filePath);

              case 23:
                _ref4 = _context2.sent;
                code = _ref4.code;
                binaryData = _ref4.binaryData;
                mimeType = _ref4.mimeType;


                code = code || binaryData;

                if (!(!code || !mimeType)) {
                  _context2.next = 30;
                  break;
                }

                throw new Error('Asked to compile ' + filePath + ' in production, is this file not precompiled?');

              case 30:
                return _context2.abrupt('return', { code: code, mimeType: mimeType });

              case 31:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function compileReadOnly(_x2) {
        return _ref2.apply(this, arguments);
      }

      return compileReadOnly;
    }()

    /**
     * Handles compilation in read-write mode
     *
     * @private
     */

  }, {
    key: 'fullCompile',
    value: function () {
      var _ref5 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(filePath) {
        var _this2 = this;

        var hashInfo, type, code, compiler, cache;
        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                d('Compiling ' + filePath);

                _context3.next = 3;
                return this.fileChangeCache.getHashForPath(filePath);

              case 3:
                hashInfo = _context3.sent;
                type = _mimeTypes2.default.lookup(filePath);

                if (!hashInfo.isInNodeModules) {
                  _context3.next = 13;
                  break;
                }

                _context3.t0 = hashInfo.sourceCode;

                if (_context3.t0) {
                  _context3.next = 11;
                  break;
                }

                _context3.next = 10;
                return _promise.pfs.readFile(filePath, 'utf8');

              case 10:
                _context3.t0 = _context3.sent;

              case 11:
                code = _context3.t0;
                return _context3.abrupt('return', { code: code, mimeType: type });

              case 13:
                compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];


                if (!compiler) {
                  d('Falling back to passthrough compiler for ' + filePath);
                  compiler = this.fallbackCompiler;
                }

                if (compiler) {
                  _context3.next = 17;
                  break;
                }

                throw new Error('Couldn\'t find a compiler for ' + filePath);

              case 17:
                cache = this.cachesForCompilers.get(compiler);
                _context3.next = 20;
                return cache.getOrFetch(filePath, function (filePath, hashInfo) {
                  return _this2.compileUncached(filePath, hashInfo, compiler);
                });

              case 20:
                return _context3.abrupt('return', _context3.sent);

              case 21:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function fullCompile(_x3) {
        return _ref5.apply(this, arguments);
      }

      return fullCompile;
    }()

    /**
     * Handles invoking compilers independent of caching
     *
     * @private
     */

  }, {
    key: 'compileUncached',
    value: function () {
      var _ref6 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4(filePath, hashInfo, compiler) {
        var inputMimeType, ctx, code, dependentFiles, result, shouldInlineHtmlify, isPassthrough;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                inputMimeType = _mimeTypes2.default.lookup(filePath);

                if (!hashInfo.isFileBinary) {
                  _context4.next = 11;
                  break;
                }

                _context4.t0 = hashInfo.binaryData;

                if (_context4.t0) {
                  _context4.next = 7;
                  break;
                }

                _context4.next = 6;
                return _promise.pfs.readFile(filePath);

              case 6:
                _context4.t0 = _context4.sent;

              case 7:
                _context4.t1 = _context4.t0;
                _context4.t2 = inputMimeType;
                _context4.t3 = [];
                return _context4.abrupt('return', {
                  binaryData: _context4.t1,
                  mimeType: _context4.t2,
                  dependentFiles: _context4.t3
                });

              case 11:
                ctx = {};
                _context4.t4 = hashInfo.sourceCode;

                if (_context4.t4) {
                  _context4.next = 17;
                  break;
                }

                _context4.next = 16;
                return _promise.pfs.readFile(filePath, 'utf8');

              case 16:
                _context4.t4 = _context4.sent;

              case 17:
                code = _context4.t4;
                _context4.next = 20;
                return compiler.shouldCompileFile(code, ctx);

              case 20:
                if (_context4.sent) {
                  _context4.next = 23;
                  break;
                }

                d('Compiler returned false for shouldCompileFile: ' + filePath);
                return _context4.abrupt('return', { code: code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] });

              case 23:
                _context4.next = 25;
                return compiler.determineDependentFiles(code, filePath, ctx);

              case 25:
                dependentFiles = _context4.sent;


                d('Using compiler options: ' + (0, _stringify2.default)(compiler.compilerOptions));
                _context4.next = 29;
                return compiler.compile(code, filePath, ctx);

              case 29:
                result = _context4.sent;
                shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';
                isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);

                if (!(finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough)) {
                  _context4.next = 36;
                  break;
                }

                return _context4.abrupt('return', (0, _assign2.default)(result, { dependentFiles: dependentFiles }));

              case 36:
                d('Recursively compiling result of ' + filePath + ' with non-final MIME type ' + result.mimeType + ', input was ' + inputMimeType);

                hashInfo = (0, _assign2.default)({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);
                compiler = this.compilersByMimeType[result.mimeType || '__lolnothere'];

                if (compiler) {
                  _context4.next = 42;
                  break;
                }

                d('Recursive compile failed - intermediate result: ' + (0, _stringify2.default)(result));

                throw new Error('Compiling ' + filePath + ' resulted in a MIME type of ' + result.mimeType + ', which we don\'t know how to handle');

              case 42:
                _context4.next = 44;
                return this.compileUncached(filePath + '.' + _mimeTypes2.default.extension(result.mimeType || 'txt'), hashInfo, compiler);

              case 44:
                return _context4.abrupt('return', _context4.sent);

              case 45:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function compileUncached(_x4, _x5, _x6) {
        return _ref6.apply(this, arguments);
      }

      return compileUncached;
    }()

    /**
     * Pre-caches an entire directory of files recursively. Usually used for
     * building custom compiler tooling.
     *
     * @param  {string} rootDirectory  The top-level directory to compile
     *
     * @param  {Function} shouldCompile (optional)  A Function which allows the
     *                                  caller to disable compiling certain files.
     *                                  It takes a fully-qualified path to a file,
     *                                  and should return a Boolean.
     *
     * @return {Promise}  Completion.
     */

  }, {
    key: 'compileAll',
    value: function () {
      var _ref7 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5(rootDirectory) {
        var _this3 = this;

        var shouldCompile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var should;
        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                should = shouldCompile || function () {
                  return true;
                };

                _context5.next = 3;
                return (0, _forAllFiles.forAllFiles)(rootDirectory, function (f) {
                  if (!should(f)) return;

                  d('Compiling ' + f);
                  return _this3.compile(f, _this3.compilersByMimeType);
                });

              case 3:
              case 'end':
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function compileAll(_x8) {
        return _ref7.apply(this, arguments);
      }

      return compileAll;
    }()

    /*
     * Sync Methods
     */

  }, {
    key: 'compileSync',
    value: function compileSync(filePath) {
      return this.readOnlyMode ? this.compileReadOnlySync(filePath) : this.fullCompileSync(filePath);
    }
  }, {
    key: 'saveConfigurationSync',
    value: function saveConfigurationSync() {
      var _this4 = this;

      var serializedCompilerOpts = (0, _keys2.default)(this.compilersByMimeType).reduce(function (acc, x) {
        var compiler = _this4.compilersByMimeType[x];
        var Klass = (0, _getPrototypeOf2.default)(compiler).constructor;

        var val = {
          name: Klass.name,
          inputMimeTypes: Klass.getInputMimeTypes(),
          compilerOptions: compiler.compilerOptions,
          compilerVersion: compiler.getCompilerVersion()
        };

        acc[x] = val;
        return acc;
      }, {});

      var info = {
        fileChangeCache: this.fileChangeCache.getSavedData(),
        compilers: serializedCompilerOpts
      };

      var target = _path2.default.join(this.rootCacheDir, 'compiler-info.json.gz');
      var buf = _zlib2.default.gzipSync(new Buffer((0, _stringify2.default)(info)));
      _fs2.default.writeFileSync(target, buf);
    }
  }, {
    key: 'compileReadOnlySync',
    value: function compileReadOnlySync(filePath) {
      // We guarantee that node_modules are always shipped directly
      var type = _mimeTypes2.default.lookup(filePath);
      if (_fileChangeCache2.default.isInNodeModules(filePath)) {
        return {
          mimeType: type || 'application/javascript',
          code: _fs2.default.readFileSync(filePath, 'utf8')
        };
      }

      var hashInfo = this.fileChangeCache.getHashForPathSync(filePath);

      // We guarantee that node_modules are always shipped directly
      if (hashInfo.isInNodeModules) {
        return {
          mimeType: type,
          code: hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8')
        };
      }

      // NB: Here, we're basically only using the compiler here to find
      // the appropriate CompileCache
      var compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

      if (!compiler) {
        compiler = this.fallbackCompiler;

        var _compiler$getSync = compiler.getSync(filePath);

        var _code2 = _compiler$getSync.code;
        var _binaryData2 = _compiler$getSync.binaryData;
        var _mimeType2 = _compiler$getSync.mimeType;

        return { code: _code2 || _binaryData2, mimeType: _mimeType2 };
      }

      var cache = this.cachesForCompilers.get(compiler);

      var _cache$getSync = cache.getSync(filePath);

      var code = _cache$getSync.code;
      var binaryData = _cache$getSync.binaryData;
      var mimeType = _cache$getSync.mimeType;


      code = code || binaryData;
      if (!code || !mimeType) {
        throw new Error('Asked to compile ' + filePath + ' in production, is this file not precompiled?');
      }

      return { code: code, mimeType: mimeType };
    }
  }, {
    key: 'fullCompileSync',
    value: function fullCompileSync(filePath) {
      var _this5 = this;

      d('Compiling ' + filePath);

      var hashInfo = this.fileChangeCache.getHashForPathSync(filePath);
      var type = _mimeTypes2.default.lookup(filePath);

      if (hashInfo.isInNodeModules) {
        var code = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');
        return { code: code, mimeType: type };
      }

      var compiler = CompilerHost.shouldPassthrough(hashInfo) ? this.getPassthroughCompiler() : this.compilersByMimeType[type || '__lolnothere'];

      if (!compiler) {
        d('Falling back to passthrough compiler for ' + filePath);
        compiler = this.fallbackCompiler;
      }

      if (!compiler) {
        throw new Error('Couldn\'t find a compiler for ' + filePath);
      }

      var cache = this.cachesForCompilers.get(compiler);
      return cache.getOrFetchSync(filePath, function (filePath, hashInfo) {
        return _this5.compileUncachedSync(filePath, hashInfo, compiler);
      });
    }
  }, {
    key: 'compileUncachedSync',
    value: function compileUncachedSync(filePath, hashInfo, compiler) {
      var inputMimeType = _mimeTypes2.default.lookup(filePath);

      if (hashInfo.isFileBinary) {
        return {
          binaryData: hashInfo.binaryData || _fs2.default.readFileSync(filePath),
          mimeType: inputMimeType,
          dependentFiles: []
        };
      }

      var ctx = {};
      var code = hashInfo.sourceCode || _fs2.default.readFileSync(filePath, 'utf8');

      if (!compiler.shouldCompileFileSync(code, ctx)) {
        d('Compiler returned false for shouldCompileFile: ' + filePath);
        return { code: code, mimeType: _mimeTypes2.default.lookup(filePath), dependentFiles: [] };
      }

      var dependentFiles = compiler.determineDependentFilesSync(code, filePath, ctx);

      var result = compiler.compileSync(code, filePath, ctx);

      var shouldInlineHtmlify = inputMimeType !== 'text/html' && result.mimeType === 'text/html';

      var isPassthrough = result.mimeType === 'text/plain' || !result.mimeType || CompilerHost.shouldPassthrough(hashInfo);

      if (finalForms[result.mimeType] && !shouldInlineHtmlify || isPassthrough) {
        // Got something we can use in-browser, let's return it
        return (0, _assign2.default)(result, { dependentFiles: dependentFiles });
      } else {
        d('Recursively compiling result of ' + filePath + ' with non-final MIME type ' + result.mimeType + ', input was ' + inputMimeType);

        hashInfo = (0, _assign2.default)({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);
        compiler = this.compilersByMimeType[result.mimeType || '__lolnothere'];

        if (!compiler) {
          d('Recursive compile failed - intermediate result: ' + (0, _stringify2.default)(result));

          throw new Error('Compiling ' + filePath + ' resulted in a MIME type of ' + result.mimeType + ', which we don\'t know how to handle');
        }

        return this.compileUncachedSync(filePath + '.' + _mimeTypes2.default.extension(result.mimeType || 'txt'), hashInfo, compiler);
      }
    }
  }, {
    key: 'compileAllSync',
    value: function compileAllSync(rootDirectory) {
      var _this6 = this;

      var shouldCompile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var should = shouldCompile || function () {
        return true;
      };

      (0, _forAllFiles.forAllFilesSync)(rootDirectory, function (f) {
        if (!should(f)) return;
        return _this6.compileSync(f, _this6.compilersByMimeType);
      });
    }

    /*
     * Other stuff
     */

    /**
     * Returns the passthrough compiler
     *
     * @private
     */

  }, {
    key: 'getPassthroughCompiler',
    value: function getPassthroughCompiler() {
      return this.compilersByMimeType['text/plain'];
    }

    /**
     * Determines whether we should even try to compile the content. Note that in
     * some cases, content will still be in cache even if this returns true, and
     * in other cases (isInNodeModules), we'll know explicitly to not even bother
     * looking in the cache.
     *
     * @private
     */

  }], [{
    key: 'createReadonlyFromConfiguration',
    value: function () {
      var _ref8 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6(rootCacheDir, appRoot) {
        var fallbackCompiler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var target, buf, info, fileChangeCache, compilers;
        return _regenerator2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
                _context6.next = 3;
                return _promise.pfs.readFile(target);

              case 3:
                buf = _context6.sent;
                _context6.t0 = JSON;
                _context6.next = 7;
                return _promise.pzlib.gunzip(buf);

              case 7:
                _context6.t1 = _context6.sent;
                info = _context6.t0.parse.call(_context6.t0, _context6.t1);
                fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);
                compilers = (0, _keys2.default)(info.compilers).reduce(function (acc, x) {
                  var cur = info.compilers[x];
                  acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);

                  return acc;
                }, {});
                return _context6.abrupt('return', new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler));

              case 12:
              case 'end':
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function createReadonlyFromConfiguration(_x11, _x12) {
        return _ref8.apply(this, arguments);
      }

      return createReadonlyFromConfiguration;
    }()

    /**
     * Creates a development-mode CompilerHost from the previously saved
     * configuration.
     *
     * @param  {string} rootCacheDir  The root directory to use for the cache. This
     *                                cache must have cache information saved via
     *                                {@link saveConfiguration}
     *
     * @param  {string} appRoot  The top-level directory for your application (i.e.
     *                           the one which has your package.json).
     *
     * @param  {Object} compilersByMimeType  an Object whose keys are input MIME
     *                                       types and whose values are instances
     *                                       of CompilerBase. Create this via the
     *                                       {@link createCompilers} method in
     *                                       config-parser.
     *
     * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled
     *                                         which doesn't have a matching compiler,
     *                                         this compiler will be used instead. If
     *                                         null, will fail compilation. A good
     *                                         alternate fallback is the compiler for
     *                                         'text/plain', which is guaranteed to be
     *                                         present.
     *
     * @return {Promise<CompilerHost>}  A read-only CompilerHost
     */

  }, {
    key: 'createFromConfiguration',
    value: function () {
      var _ref9 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7(rootCacheDir, appRoot, compilersByMimeType) {
        var fallbackCompiler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var target, buf, info, fileChangeCache;
        return _regenerator2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
                _context7.next = 3;
                return _promise.pfs.readFile(target);

              case 3:
                buf = _context7.sent;
                _context7.t0 = JSON;
                _context7.next = 7;
                return _promise.pzlib.gunzip(buf);

              case 7:
                _context7.t1 = _context7.sent;
                info = _context7.t0.parse.call(_context7.t0, _context7.t1);
                fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);


                (0, _keys2.default)(info.compilers).forEach(function (x) {
                  var cur = info.compilers[x];
                  compilersByMimeType[x].compilerOptions = cur.compilerOptions;
                });

                return _context7.abrupt('return', new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler));

              case 12:
              case 'end':
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function createFromConfiguration(_x14, _x15, _x16) {
        return _ref9.apply(this, arguments);
      }

      return createFromConfiguration;
    }()
  }, {
    key: 'createReadonlyFromConfigurationSync',
    value: function createReadonlyFromConfigurationSync(rootCacheDir, appRoot) {
      var fallbackCompiler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
      var buf = _fs2.default.readFileSync(target);
      var info = JSON.parse(_zlib2.default.gunzipSync(buf));

      var fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, true);

      var compilers = (0, _keys2.default)(info.compilers).reduce(function (acc, x) {
        var cur = info.compilers[x];
        acc[x] = new _readOnlyCompiler2.default(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);

        return acc;
      }, {});

      return new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler);
    }
  }, {
    key: 'createFromConfigurationSync',
    value: function createFromConfigurationSync(rootCacheDir, appRoot, compilersByMimeType) {
      var fallbackCompiler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      var target = _path2.default.join(rootCacheDir, 'compiler-info.json.gz');
      var buf = _fs2.default.readFileSync(target);
      var info = JSON.parse(_zlib2.default.gunzipSync(buf));

      var fileChangeCache = _fileChangeCache2.default.loadFromData(info.fileChangeCache, appRoot, false);

      (0, _keys2.default)(info.compilers).forEach(function (x) {
        var cur = info.compilers[x];
        compilersByMimeType[x].compilerOptions = cur.compilerOptions;
      });

      return new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler);
    }
  }, {
    key: 'shouldPassthrough',
    value: function shouldPassthrough(hashInfo) {
      return hashInfo.isMinified || hashInfo.isInNodeModules || hashInfo.hasSourceMap || hashInfo.isFileBinary;
    }
  }]);
  return CompilerHost;
}();

exports.default = CompilerHost;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21waWxlci1ob3N0LmpzIl0sIm5hbWVzIjpbImQiLCJyZXF1aXJlIiwiaW5pdCIsImZpbmFsRm9ybXMiLCJDb21waWxlckhvc3QiLCJyb290Q2FjaGVEaXIiLCJjb21waWxlcnMiLCJmaWxlQ2hhbmdlQ2FjaGUiLCJyZWFkT25seU1vZGUiLCJmYWxsYmFja0NvbXBpbGVyIiwiY29tcGlsZXJzQnlNaW1lVHlwZSIsImFwcFJvb3QiLCJjYWNoZXNGb3JDb21waWxlcnMiLCJyZWR1Y2UiLCJhY2MiLCJ4IiwiY29tcGlsZXIiLCJoYXMiLCJzZXQiLCJjcmVhdGVGcm9tQ29tcGlsZXIiLCJzZXJpYWxpemVkQ29tcGlsZXJPcHRzIiwiS2xhc3MiLCJjb25zdHJ1Y3RvciIsInZhbCIsIm5hbWUiLCJpbnB1dE1pbWVUeXBlcyIsImdldElucHV0TWltZVR5cGVzIiwiY29tcGlsZXJPcHRpb25zIiwiY29tcGlsZXJWZXJzaW9uIiwiZ2V0Q29tcGlsZXJWZXJzaW9uIiwiaW5mbyIsImdldFNhdmVkRGF0YSIsInRhcmdldCIsImpvaW4iLCJnemlwIiwiQnVmZmVyIiwiYnVmIiwid3JpdGVGaWxlIiwiZmlsZVBhdGgiLCJjb21waWxlUmVhZE9ubHkiLCJmdWxsQ29tcGlsZSIsInR5cGUiLCJsb29rdXAiLCJpc0luTm9kZU1vZHVsZXMiLCJyZWFkRmlsZSIsIm1pbWVUeXBlIiwiY29kZSIsImdldEhhc2hGb3JQYXRoIiwiaGFzaEluZm8iLCJzaG91bGRQYXNzdGhyb3VnaCIsImdldFBhc3N0aHJvdWdoQ29tcGlsZXIiLCJnZXQiLCJiaW5hcnlEYXRhIiwiY2FjaGUiLCJFcnJvciIsInNvdXJjZUNvZGUiLCJnZXRPckZldGNoIiwiY29tcGlsZVVuY2FjaGVkIiwiaW5wdXRNaW1lVHlwZSIsImlzRmlsZUJpbmFyeSIsImRlcGVuZGVudEZpbGVzIiwiY3R4Iiwic2hvdWxkQ29tcGlsZUZpbGUiLCJkZXRlcm1pbmVEZXBlbmRlbnRGaWxlcyIsImNvbXBpbGUiLCJyZXN1bHQiLCJzaG91bGRJbmxpbmVIdG1saWZ5IiwiaXNQYXNzdGhyb3VnaCIsImV4dGVuc2lvbiIsInJvb3REaXJlY3RvcnkiLCJzaG91bGRDb21waWxlIiwic2hvdWxkIiwiZiIsImNvbXBpbGVSZWFkT25seVN5bmMiLCJmdWxsQ29tcGlsZVN5bmMiLCJnemlwU3luYyIsIndyaXRlRmlsZVN5bmMiLCJyZWFkRmlsZVN5bmMiLCJnZXRIYXNoRm9yUGF0aFN5bmMiLCJnZXRTeW5jIiwiZ2V0T3JGZXRjaFN5bmMiLCJjb21waWxlVW5jYWNoZWRTeW5jIiwic2hvdWxkQ29tcGlsZUZpbGVTeW5jIiwiZGV0ZXJtaW5lRGVwZW5kZW50RmlsZXNTeW5jIiwiY29tcGlsZVN5bmMiLCJKU09OIiwiZ3VuemlwIiwicGFyc2UiLCJsb2FkRnJvbURhdGEiLCJjdXIiLCJmb3JFYWNoIiwiZ3VuemlwU3luYyIsImlzTWluaWZpZWQiLCJoYXNTb3VyY2VNYXAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNQSxJQUFJQyxRQUFRLGdCQUFSLEVBQTBCLGdDQUExQixDQUFWOztBQUVBQSxRQUFRLGtCQUFSLEVBQTRCQyxJQUE1Qjs7QUFFQTtBQUNBLElBQU1DLGFBQWE7QUFDakIscUJBQW1CLElBREY7QUFFakIsNEJBQTBCLElBRlQ7QUFHakIsZUFBYSxJQUhJO0FBSWpCLGNBQVksSUFKSztBQUtqQixtQkFBaUIsSUFMQTtBQU1qQixzQkFBb0I7QUFOSCxDQUFuQjs7QUFTQTs7Ozs7Ozs7Ozs7Ozs7O0lBY3FCQyxZO0FBQ25COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQSx3QkFBWUMsWUFBWixFQUEwQkMsU0FBMUIsRUFBcUNDLGVBQXJDLEVBQXNEQyxZQUF0RCxFQUE2RjtBQUFBLFFBQXpCQyxnQkFBeUIsdUVBQU4s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LEdBQXlDOEQsSUFBSTlELGVBQTdDO0FBQ0QsT0FIRDs7QUFLQSxhQUFPLElBQUl2QixZQUFKLENBQWlCQyxZQUFqQixFQUErQkssbUJBQS9CLEVBQW9ESCxlQUFwRCxFQUFxRSxLQUFyRSxFQUE0RUUsZ0JBQTVFLENBQVA7QUFDRDs7O3NDQTJMd0J1QyxRLEVBQVU7QUFDakMsYUFBT0EsU0FBUzRDLFVBQVQsSUFBdUI1QyxTQUFTTCxlQUFoQyxJQUFtREssU0FBUzZDLFlBQTVELElBQTRFN0MsU0FBU1csWUFBNUY7QUFDRDs7Ozs7a0JBbGpCa0J2RCxZIiwiZmlsZSI6ImNvbXBpbGVyLWhvc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbWltZVR5cGVzIGZyb20gJ0BwYXVsY2JldHRzL21pbWUtdHlwZXMnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB6bGliIGZyb20gJ3psaWInO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQge3BmcywgcHpsaWJ9IGZyb20gJy4vcHJvbWlzZSc7XG5cbmltcG9ydCB7Zm9yQWxsRmlsZXMsIGZvckFsbEZpbGVzU3luY30gZnJvbSAnLi9mb3ItYWxsLWZpbGVzJztcbmltcG9ydCBDb21waWxlQ2FjaGUgZnJvbSAnLi9jb21waWxlLWNhY2hlJztcbmltcG9ydCBGaWxlQ2hhbmdlZENhY2hlIGZyb20gJy4vZmlsZS1jaGFuZ2UtY2FjaGUnO1xuaW1wb3J0IFJlYWRPbmx5Q29tcGlsZXIgZnJvbSAnLi9yZWFkLW9ubHktY29tcGlsZXInO1xuXG5jb25zdCBkID0gcmVxdWlyZSgnZGVidWctZWxlY3Ryb24nKSgnZWxlY3Ryb24tY29tcGlsZTpjb21waWxlci1ob3N0Jyk7XG5cbnJlcXVpcmUoJy4vcmlnLW1pbWUtdHlwZXMnKS5pbml0KCk7XG5cbi8vIFRoaXMgaXNuJ3QgZXZlbiBteVxuY29uc3QgZmluYWxGb3JtcyA9IHtcbiAgJ3RleHQvamF2YXNjcmlwdCc6IHRydWUsXG4gICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JzogdHJ1ZSxcbiAgJ3RleHQvaHRtbCc6IHRydWUsXG4gICd0ZXh0L2Nzcyc6IHRydWUsXG4gICdpbWFnZS9zdmcreG1sJzogdHJ1ZSxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiB0cnVlXG59O1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgdGhlIHRvcC1sZXZlbCBjbGFzcyB0aGF0IGVuY2Fwc3VsYXRlcyBhbGwgb2YgdGhlIGxvZ2ljIG9mXG4gKiBjb21waWxpbmcgYW5kIGNhY2hpbmcgYXBwbGljYXRpb24gY29kZS4gSWYgeW91J3JlIGxvb2tpbmcgZm9yIGEgXCJNYWluIGNsYXNzXCIsXG4gKiB0aGlzIGlzIGl0LlxuICpcbiAqIFRoaXMgY2xhc3MgY2FuIGJlIGNyZWF0ZWQgZGlyZWN0bHkgYnV0IGl0IGlzIHVzdWFsbHkgY3JlYXRlZCB2aWEgdGhlIG1ldGhvZHNcbiAqIGluIGNvbmZpZy1wYXJzZXIsIHdoaWNoIHdpbGwgYW1vbmcgb3RoZXIgdGhpbmdzLCBzZXQgdXAgdGhlIGNvbXBpbGVyIG9wdGlvbnNcbiAqIGdpdmVuIGEgcHJvamVjdCByb290LlxuICpcbiAqIENvbXBpbGVySG9zdCBpcyBhbHNvIHRoZSB0b3AtbGV2ZWwgY2xhc3MgdGhhdCBrbm93cyBob3cgdG8gc2VyaWFsaXplIGFsbCBvZiB0aGVcbiAqIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byByZWNyZWF0ZSBpdHNlbGYsIGVpdGhlciBhcyBhIGRldmVsb3BtZW50IGhvc3QgKGkuZS5cbiAqIHdpbGwgYWxsb3cgY2FjaGUgbWlzc2VzIGFuZCBhY3R1YWwgY29tcGlsYXRpb24pLCBvciBhcyBhIHJlYWQtb25seSB2ZXJzaW9uIG9mXG4gKiBpdHNlbGYgZm9yIHByb2R1Y3Rpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBpbGVySG9zdCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENvbXBpbGVySG9zdC4gWW91IHByb2JhYmx5IHdhbnQgdG8gdXNlIHRoZSBtZXRob2RzXG4gICAqIGluIGNvbmZpZy1wYXJzZXIgZm9yIGRldmVsb3BtZW50LCBvciB7QGxpbmsgY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvbn1cbiAgICogZm9yIHByb2R1Y3Rpb24gaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgIFRoZSByb290IGRpcmVjdG9yeSB0byB1c2UgZm9yIHRoZSBjYWNoZVxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbXBpbGVycyAgYW4gT2JqZWN0IHdob3NlIGtleXMgYXJlIGlucHV0IE1JTUUgdHlwZXMgYW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aG9zZSB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiBDb21waWxlckJhc2UuIENyZWF0ZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB2aWEgdGhlIHtAbGluayBjcmVhdGVDb21waWxlcnN9IG1ldGhvZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLXBhcnNlci5cbiAgICpcbiAgICogQHBhcmFtICB7RmlsZUNoYW5nZWRDYWNoZX0gZmlsZUNoYW5nZUNhY2hlICBBIGZpbGUtY2hhbmdlIGNhY2hlIHRoYXQgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbGx5IHByZS1sb2FkZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IHJlYWRPbmx5TW9kZSAgSWYgVHJ1ZSwgY2FjaGUgbWlzc2VzIHdpbGwgZmFpbCBhbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21waWxhdGlvbiB3aWxsIG5vdCBiZSBhdHRlbXB0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge0NvbXBpbGVyQmFzZX0gZmFsbGJhY2tDb21waWxlciAob3B0aW9uYWwpICBXaGVuIGEgZmlsZSBpcyBjb21waWxlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpY2ggZG9lc24ndCBoYXZlIGEgbWF0Y2hpbmcgY29tcGlsZXIsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIGNvbXBpbGVyIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBJZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCwgd2lsbCBmYWlsIGNvbXBpbGF0aW9uLiBBIGdvb2RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVybmF0ZSBmYWxsYmFjayBpcyB0aGUgY29tcGlsZXIgZm9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGV4dC9wbGFpbicsIHdoaWNoIGlzIGd1YXJhbnRlZWQgdG8gYmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihyb290Q2FjaGVEaXIsIGNvbXBpbGVycywgZmlsZUNoYW5nZUNhY2hlLCByZWFkT25seU1vZGUsIGZhbGxiYWNrQ29tcGlsZXIgPSBudWxsKSB7XG4gICAgbGV0IGNvbXBpbGVyc0J5TWltZVR5cGUgPSBPYmplY3QuYXNzaWduKHt9LCBjb21waWxlcnMpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywge3Jvb3RDYWNoZURpciwgY29tcGlsZXJzQnlNaW1lVHlwZSwgZmlsZUNoYW5nZUNhY2hlLCByZWFkT25seU1vZGUsIGZhbGxiYWNrQ29tcGlsZXJ9KTtcbiAgICB0aGlzLmFwcFJvb3QgPSB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5hcHBSb290O1xuXG4gICAgdGhpcy5jYWNoZXNGb3JDb21waWxlcnMgPSBPYmplY3Qua2V5cyhjb21waWxlcnNCeU1pbWVUeXBlKS5yZWR1Y2UoKGFjYywgeCkgPT4ge1xuICAgICAgbGV0IGNvbXBpbGVyID0gY29tcGlsZXJzQnlNaW1lVHlwZVt4XTtcbiAgICAgIGlmIChhY2MuaGFzKGNvbXBpbGVyKSkgcmV0dXJuIGFjYztcblxuICAgICAgYWNjLnNldChcbiAgICAgICAgY29tcGlsZXIsXG4gICAgICAgIENvbXBpbGVDYWNoZS5jcmVhdGVGcm9tQ29tcGlsZXIocm9vdENhY2hlRGlyLCBjb21waWxlciwgZmlsZUNoYW5nZUNhY2hlLCByZWFkT25seU1vZGUpKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgbmV3IE1hcCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcHJvZHVjdGlvbi1tb2RlIENvbXBpbGVySG9zdCBmcm9tIHRoZSBwcmV2aW91c2x5IHNhdmVkXG4gICAqIGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSByb290Q2FjaGVEaXIgIFRoZSByb290IGRpcmVjdG9yeSB0byB1c2UgZm9yIHRoZSBjYWNoZS4gVGhpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUgbXVzdCBoYXZlIGNhY2hlIGluZm9ybWF0aW9uIHNhdmVkIHZpYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BsaW5rIHNhdmVDb25maWd1cmF0aW9ufVxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGFwcFJvb3QgIFRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IGZvciB5b3VyIGFwcGxpY2F0aW9uIChpLmUuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSB3aGljaCBoYXMgeW91ciBwYWNrYWdlLmpzb24pLlxuICAgKlxuICAgKiBAcGFyYW0gIHtDb21waWxlckJhc2V9IGZhbGxiYWNrQ29tcGlsZXIgKG9wdGlvbmFsKSAgV2hlbiBhIGZpbGUgaXMgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIGNvbXBpbGVyLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBjb21waWxlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gSWZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIHdpbGwgZmFpbCBjb21waWxhdGlvbi4gQSBnb29kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGUgZmFsbGJhY2sgaXMgdGhlIGNvbXBpbGVyIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQvcGxhaW4nLCB3aGljaCBpcyBndWFyYW50ZWVkIHRvIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbXBpbGVySG9zdD59ICBBIHJlYWQtb25seSBDb21waWxlckhvc3RcbiAgICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVSZWFkb25seUZyb21Db25maWd1cmF0aW9uKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgZmFsbGJhY2tDb21waWxlcj1udWxsKSB7XG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbihyb290Q2FjaGVEaXIsICdjb21waWxlci1pbmZvLmpzb24uZ3onKTtcbiAgICBsZXQgYnVmID0gYXdhaXQgcGZzLnJlYWRGaWxlKHRhcmdldCk7XG4gICAgbGV0IGluZm8gPSBKU09OLnBhcnNlKGF3YWl0IHB6bGliLmd1bnppcChidWYpKTtcblxuICAgIGxldCBmaWxlQ2hhbmdlQ2FjaGUgPSBGaWxlQ2hhbmdlZENhY2hlLmxvYWRGcm9tRGF0YShpbmZvLmZpbGVDaGFuZ2VDYWNoZSwgYXBwUm9vdCwgdHJ1ZSk7XG5cbiAgICBsZXQgY29tcGlsZXJzID0gT2JqZWN0LmtleXMoaW5mby5jb21waWxlcnMpLnJlZHVjZSgoYWNjLCB4KSA9PiB7XG4gICAgICBsZXQgY3VyID0gaW5mby5jb21waWxlcnNbeF07XG4gICAgICBhY2NbeF0gPSBuZXcgUmVhZE9ubHlDb21waWxlcihjdXIubmFtZSwgY3VyLmNvbXBpbGVyVmVyc2lvbiwgY3VyLmNvbXBpbGVyT3B0aW9ucywgY3VyLmlucHV0TWltZVR5cGVzKTtcblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4gbmV3IENvbXBpbGVySG9zdChyb290Q2FjaGVEaXIsIGNvbXBpbGVycywgZmlsZUNoYW5nZUNhY2hlLCB0cnVlLCBmYWxsYmFja0NvbXBpbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZGV2ZWxvcG1lbnQtbW9kZSBDb21waWxlckhvc3QgZnJvbSB0aGUgcHJldmlvdXNseSBzYXZlZFxuICAgKiBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3RDYWNoZURpciAgVGhlIHJvb3QgZGlyZWN0b3J5IHRvIHVzZSBmb3IgdGhlIGNhY2hlLiBUaGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZSBtdXN0IGhhdmUgY2FjaGUgaW5mb3JtYXRpb24gc2F2ZWQgdmlhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgc2F2ZUNvbmZpZ3VyYXRpb259XG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYXBwUm9vdCAgVGhlIHRvcC1sZXZlbCBkaXJlY3RvcnkgZm9yIHlvdXIgYXBwbGljYXRpb24gKGkuZS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb25lIHdoaWNoIGhhcyB5b3VyIHBhY2thZ2UuanNvbikuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29tcGlsZXJzQnlNaW1lVHlwZSAgYW4gT2JqZWN0IHdob3NlIGtleXMgYXJlIGlucHV0IE1JTUVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlcyBhbmQgd2hvc2UgdmFsdWVzIGFyZSBpbnN0YW5jZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiBDb21waWxlckJhc2UuIENyZWF0ZSB0aGlzIHZpYSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgY3JlYXRlQ29tcGlsZXJzfSBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWctcGFyc2VyLlxuICAgKlxuICAgKiBAcGFyYW0gIHtDb21waWxlckJhc2V9IGZhbGxiYWNrQ29tcGlsZXIgKG9wdGlvbmFsKSAgV2hlbiBhIGZpbGUgaXMgY29tcGlsZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWNoIGRvZXNuJ3QgaGF2ZSBhIG1hdGNoaW5nIGNvbXBpbGVyLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyBjb21waWxlciB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gSWZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsIHdpbGwgZmFpbCBjb21waWxhdGlvbi4gQSBnb29kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGUgZmFsbGJhY2sgaXMgdGhlIGNvbXBpbGVyIGZvclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQvcGxhaW4nLCB3aGljaCBpcyBndWFyYW50ZWVkIHRvIGJlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPENvbXBpbGVySG9zdD59ICBBIHJlYWQtb25seSBDb21waWxlckhvc3RcbiAgICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVGcm9tQ29uZmlndXJhdGlvbihyb290Q2FjaGVEaXIsIGFwcFJvb3QsIGNvbXBpbGVyc0J5TWltZVR5cGUsIGZhbGxiYWNrQ29tcGlsZXI9bnVsbCkge1xuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4ocm9vdENhY2hlRGlyLCAnY29tcGlsZXItaW5mby5qc29uLmd6Jyk7XG4gICAgbGV0IGJ1ZiA9IGF3YWl0IHBmcy5yZWFkRmlsZSh0YXJnZXQpO1xuICAgIGxldCBpbmZvID0gSlNPTi5wYXJzZShhd2FpdCBwemxpYi5ndW56aXAoYnVmKSk7XG5cbiAgICBsZXQgZmlsZUNoYW5nZUNhY2hlID0gRmlsZUNoYW5nZWRDYWNoZS5sb2FkRnJvbURhdGEoaW5mby5maWxlQ2hhbmdlQ2FjaGUsIGFwcFJvb3QsIGZhbHNlKTtcblxuICAgIE9iamVjdC5rZXlzKGluZm8uY29tcGlsZXJzKS5mb3JFYWNoKCh4KSA9PiB7XG4gICAgICBsZXQgY3VyID0gaW5mby5jb21waWxlcnNbeF07XG4gICAgICBjb21waWxlcnNCeU1pbWVUeXBlW3hdLmNvbXBpbGVyT3B0aW9ucyA9IGN1ci5jb21waWxlck9wdGlvbnM7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IENvbXBpbGVySG9zdChyb290Q2FjaGVEaXIsIGNvbXBpbGVyc0J5TWltZVR5cGUsIGZpbGVDaGFuZ2VDYWNoZSwgZmFsc2UsIGZhbGxiYWNrQ29tcGlsZXIpO1xuICB9XG5cblxuICAvKipcbiAgICogU2F2ZXMgdGhlIGN1cnJlbnQgY29tcGlsZXIgY29uZmlndXJhdGlvbiB0byBhIGZpbGUgdGhhdFxuICAgKiB7QGxpbmsgY3JlYXRlUmVhZG9ubHlGcm9tQ29uZmlndXJhdGlvbn0gY2FuIHVzZSB0byByZWNyZWF0ZSB0aGUgY3VycmVudFxuICAgKiBjb21waWxlciBlbnZpcm9ubWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgQ29tcGxldGlvblxuICAgKi9cbiAgYXN5bmMgc2F2ZUNvbmZpZ3VyYXRpb24oKSB7XG4gICAgbGV0IHNlcmlhbGl6ZWRDb21waWxlck9wdHMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGUpLnJlZHVjZSgoYWNjLCB4KSA9PiB7XG4gICAgICBsZXQgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbeF07XG4gICAgICBsZXQgS2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29tcGlsZXIpLmNvbnN0cnVjdG9yO1xuXG4gICAgICBsZXQgdmFsID0ge1xuICAgICAgICBuYW1lOiBLbGFzcy5uYW1lLFxuICAgICAgICBpbnB1dE1pbWVUeXBlczogS2xhc3MuZ2V0SW5wdXRNaW1lVHlwZXMoKSxcbiAgICAgICAgY29tcGlsZXJPcHRpb25zOiBjb21waWxlci5jb21waWxlck9wdGlvbnMsXG4gICAgICAgIGNvbXBpbGVyVmVyc2lvbjogY29tcGlsZXIuZ2V0Q29tcGlsZXJWZXJzaW9uKClcbiAgICAgIH07XG5cbiAgICAgIGFjY1t4XSA9IHZhbDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuXG4gICAgbGV0IGluZm8gPSB7XG4gICAgICBmaWxlQ2hhbmdlQ2FjaGU6IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldFNhdmVkRGF0YSgpLFxuICAgICAgY29tcGlsZXJzOiBzZXJpYWxpemVkQ29tcGlsZXJPcHRzXG4gICAgfTtcblxuICAgIGxldCB0YXJnZXQgPSBwYXRoLmpvaW4odGhpcy5yb290Q2FjaGVEaXIsICdjb21waWxlci1pbmZvLmpzb24uZ3onKTtcbiAgICBsZXQgYnVmID0gYXdhaXQgcHpsaWIuZ3ppcChuZXcgQnVmZmVyKEpTT04uc3RyaW5naWZ5KGluZm8pKSk7XG4gICAgYXdhaXQgcGZzLndyaXRlRmlsZSh0YXJnZXQsIGJ1Zik7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGlsZXMgYSBmaWxlIGFuZCByZXR1cm5zIHRoZSBjb21waWxlZCByZXN1bHQuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmlsZVBhdGggIFRoZSBwYXRoIHRvIHRoZSBmaWxlIHRvIGNvbXBpbGVcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxvYmplY3Q+fSAgQW4gT2JqZWN0IHdpdGggdGhlIGNvbXBpbGVkIHJlc3VsdFxuICAgKlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaGFzaEluZm8gIFRoZSBoYXNoIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gZ2V0SGFzaEZvclBhdGhcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgIFRoZSBzb3VyY2UgY29kZSBpZiB0aGUgZmlsZSB3YXMgYSB0ZXh0IGZpbGVcbiAgICogQHByb3BlcnR5IHtCdWZmZXJ9IGJpbmFyeURhdGEgIFRoZSBmaWxlIGlmIGl0IHdhcyBhIGJpbmFyeSBmaWxlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtaW1lVHlwZSAgVGhlIE1JTUUgdHlwZSBzYXZlZCBpbiB0aGUgY2FjaGUuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGRlcGVuZGVudEZpbGVzICBUaGUgZGVwZW5kZW50IGZpbGVzIHJldHVybmVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGluZyB0aGUgZmlsZSwgaWYgYW55LlxuICAgKi9cbiAgY29tcGlsZShmaWxlUGF0aCkge1xuICAgIHJldHVybiAodGhpcy5yZWFkT25seU1vZGUgPyB0aGlzLmNvbXBpbGVSZWFkT25seShmaWxlUGF0aCkgOiB0aGlzLmZ1bGxDb21waWxlKGZpbGVQYXRoKSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGNvbXBpbGF0aW9uIGluIHJlYWQtb25seSBtb2RlXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBjb21waWxlUmVhZE9ubHkoZmlsZVBhdGgpIHtcbiAgICAvLyBXZSBndWFyYW50ZWUgdGhhdCBub2RlX21vZHVsZXMgYXJlIGFsd2F5cyBzaGlwcGVkIGRpcmVjdGx5XG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcbiAgICBpZiAoRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoZmlsZVBhdGgpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW1lVHlwZTogdHlwZSB8fCAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXG4gICAgICAgIGNvZGU6IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgaGFzaEluZm8gPSBhd2FpdCB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aChmaWxlUGF0aCk7XG5cbiAgICAvLyBOQjogSGVyZSwgd2UncmUgYmFzaWNhbGx5IG9ubHkgdXNpbmcgdGhlIGNvbXBpbGVyIGhlcmUgdG8gZmluZFxuICAgIC8vIHRoZSBhcHByb3ByaWF0ZSBDb21waWxlQ2FjaGVcbiAgICBsZXQgY29tcGlsZXIgPSBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pID9cbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcbiAgICAgIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVt0eXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcblxuICAgIGlmICghY29tcGlsZXIpIHtcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5mYWxsYmFja0NvbXBpbGVyO1xuXG4gICAgICBsZXQgeyBjb2RlLCBiaW5hcnlEYXRhLCBtaW1lVHlwZSB9ID0gYXdhaXQgY29tcGlsZXIuZ2V0KGZpbGVQYXRoKTtcbiAgICAgIHJldHVybiB7IGNvZGU6IGNvZGUgfHwgYmluYXJ5RGF0YSwgbWltZVR5cGUgfTtcbiAgICB9XG5cbiAgICBsZXQgY2FjaGUgPSB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycy5nZXQoY29tcGlsZXIpO1xuICAgIGxldCB7Y29kZSwgYmluYXJ5RGF0YSwgbWltZVR5cGV9ID0gYXdhaXQgY2FjaGUuZ2V0KGZpbGVQYXRoKTtcblxuICAgIGNvZGUgPSBjb2RlIHx8IGJpbmFyeURhdGE7XG4gICAgaWYgKCFjb2RlIHx8ICFtaW1lVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc2tlZCB0byBjb21waWxlICR7ZmlsZVBhdGh9IGluIHByb2R1Y3Rpb24sIGlzIHRoaXMgZmlsZSBub3QgcHJlY29tcGlsZWQ/YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgY29kZSwgbWltZVR5cGUgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGNvbXBpbGF0aW9uIGluIHJlYWQtd3JpdGUgbW9kZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgZnVsbENvbXBpbGUoZmlsZVBhdGgpIHtcbiAgICBkKGBDb21waWxpbmcgJHtmaWxlUGF0aH1gKTtcblxuICAgIGxldCBoYXNoSW5mbyA9IGF3YWl0IHRoaXMuZmlsZUNoYW5nZUNhY2hlLmdldEhhc2hGb3JQYXRoKGZpbGVQYXRoKTtcbiAgICBsZXQgdHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xuXG4gICAgaWYgKGhhc2hJbmZvLmlzSW5Ob2RlTW9kdWxlcykge1xuICAgICAgbGV0IGNvZGUgPSBoYXNoSW5mby5zb3VyY2VDb2RlIHx8IGF3YWl0IHBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKTtcbiAgICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlOiB0eXBlIH07XG4gICAgfVxuXG4gICAgbGV0IGNvbXBpbGVyID0gQ29tcGlsZXJIb3N0LnNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSA/XG4gICAgICB0aGlzLmdldFBhc3N0aHJvdWdoQ29tcGlsZXIoKSA6XG4gICAgICB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbdHlwZSB8fCAnX19sb2xub3RoZXJlJ107XG5cbiAgICBpZiAoIWNvbXBpbGVyKSB7XG4gICAgICBkKGBGYWxsaW5nIGJhY2sgdG8gcGFzc3Rocm91Z2ggY29tcGlsZXIgZm9yICR7ZmlsZVBhdGh9YCk7XG4gICAgICBjb21waWxlciA9IHRoaXMuZmFsbGJhY2tDb21waWxlcjtcbiAgICB9XG5cbiAgICBpZiAoIWNvbXBpbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IGZpbmQgYSBjb21waWxlciBmb3IgJHtmaWxlUGF0aH1gKTtcbiAgICB9XG5cbiAgICBsZXQgY2FjaGUgPSB0aGlzLmNhY2hlc0ZvckNvbXBpbGVycy5nZXQoY29tcGlsZXIpO1xuICAgIHJldHVybiBhd2FpdCBjYWNoZS5nZXRPckZldGNoKFxuICAgICAgZmlsZVBhdGgsXG4gICAgICAoZmlsZVBhdGgsIGhhc2hJbmZvKSA9PiB0aGlzLmNvbXBpbGVVbmNhY2hlZChmaWxlUGF0aCwgaGFzaEluZm8sIGNvbXBpbGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBpbnZva2luZyBjb21waWxlcnMgaW5kZXBlbmRlbnQgb2YgY2FjaGluZ1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgY29tcGlsZVVuY2FjaGVkKGZpbGVQYXRoLCBoYXNoSW5mbywgY29tcGlsZXIpIHtcbiAgICBsZXQgaW5wdXRNaW1lVHlwZSA9IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpO1xuXG4gICAgaWYgKGhhc2hJbmZvLmlzRmlsZUJpbmFyeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmluYXJ5RGF0YTogaGFzaEluZm8uYmluYXJ5RGF0YSB8fCBhd2FpdCBwZnMucmVhZEZpbGUoZmlsZVBhdGgpLFxuICAgICAgICBtaW1lVHlwZTogaW5wdXRNaW1lVHlwZSxcbiAgICAgICAgZGVwZW5kZW50RmlsZXM6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCBjdHggPSB7fTtcbiAgICBsZXQgY29kZSA9IGhhc2hJbmZvLnNvdXJjZUNvZGUgfHwgYXdhaXQgcGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmOCcpO1xuXG4gICAgaWYgKCEoYXdhaXQgY29tcGlsZXIuc2hvdWxkQ29tcGlsZUZpbGUoY29kZSwgY3R4KSkpIHtcbiAgICAgIGQoYENvbXBpbGVyIHJldHVybmVkIGZhbHNlIGZvciBzaG91bGRDb21waWxlRmlsZTogJHtmaWxlUGF0aH1gKTtcbiAgICAgIHJldHVybiB7IGNvZGUsIG1pbWVUeXBlOiBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKSwgZGVwZW5kZW50RmlsZXM6IFtdIH07XG4gICAgfVxuXG4gICAgbGV0IGRlcGVuZGVudEZpbGVzID0gYXdhaXQgY29tcGlsZXIuZGV0ZXJtaW5lRGVwZW5kZW50RmlsZXMoY29kZSwgZmlsZVBhdGgsIGN0eCk7XG5cbiAgICBkKGBVc2luZyBjb21waWxlciBvcHRpb25zOiAke0pTT04uc3RyaW5naWZ5KGNvbXBpbGVyLmNvbXBpbGVyT3B0aW9ucyl9YCk7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNvbXBpbGVyLmNvbXBpbGUoY29kZSwgZmlsZVBhdGgsIGN0eCk7XG5cbiAgICBsZXQgc2hvdWxkSW5saW5lSHRtbGlmeSA9XG4gICAgICBpbnB1dE1pbWVUeXBlICE9PSAndGV4dC9odG1sJyAmJlxuICAgICAgcmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9odG1sJztcblxuICAgIGxldCBpc1Bhc3N0aHJvdWdoID1cbiAgICAgIHJlc3VsdC5taW1lVHlwZSA9PT0gJ3RleHQvcGxhaW4nIHx8XG4gICAgICAhcmVzdWx0Lm1pbWVUeXBlIHx8XG4gICAgICBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pO1xuXG4gICAgaWYgKChmaW5hbEZvcm1zW3Jlc3VsdC5taW1lVHlwZV0gJiYgIXNob3VsZElubGluZUh0bWxpZnkpIHx8IGlzUGFzc3Rocm91Z2gpIHtcbiAgICAgIC8vIEdvdCBzb21ldGhpbmcgd2UgY2FuIHVzZSBpbi1icm93c2VyLCBsZXQncyByZXR1cm4gaXRcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlc3VsdCwge2RlcGVuZGVudEZpbGVzfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQoYFJlY3Vyc2l2ZWx5IGNvbXBpbGluZyByZXN1bHQgb2YgJHtmaWxlUGF0aH0gd2l0aCBub24tZmluYWwgTUlNRSB0eXBlICR7cmVzdWx0Lm1pbWVUeXBlfSwgaW5wdXQgd2FzICR7aW5wdXRNaW1lVHlwZX1gKTtcblxuICAgICAgaGFzaEluZm8gPSBPYmplY3QuYXNzaWduKHsgc291cmNlQ29kZTogcmVzdWx0LmNvZGUsIG1pbWVUeXBlOiByZXN1bHQubWltZVR5cGUgfSwgaGFzaEluZm8pO1xuICAgICAgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbcmVzdWx0Lm1pbWVUeXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcblxuICAgICAgaWYgKCFjb21waWxlcikge1xuICAgICAgICBkKGBSZWN1cnNpdmUgY29tcGlsZSBmYWlsZWQgLSBpbnRlcm1lZGlhdGUgcmVzdWx0OiAke0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9YCk7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21waWxpbmcgJHtmaWxlUGF0aH0gcmVzdWx0ZWQgaW4gYSBNSU1FIHR5cGUgb2YgJHtyZXN1bHQubWltZVR5cGV9LCB3aGljaCB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGVgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29tcGlsZVVuY2FjaGVkKFxuICAgICAgICBgJHtmaWxlUGF0aH0uJHttaW1lVHlwZXMuZXh0ZW5zaW9uKHJlc3VsdC5taW1lVHlwZSB8fCAndHh0Jyl9YCxcbiAgICAgICAgaGFzaEluZm8sIGNvbXBpbGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJlLWNhY2hlcyBhbiBlbnRpcmUgZGlyZWN0b3J5IG9mIGZpbGVzIHJlY3Vyc2l2ZWx5LiBVc3VhbGx5IHVzZWQgZm9yXG4gICAqIGJ1aWxkaW5nIGN1c3RvbSBjb21waWxlciB0b29saW5nLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJvb3REaXJlY3RvcnkgIFRoZSB0b3AtbGV2ZWwgZGlyZWN0b3J5IHRvIGNvbXBpbGVcbiAgICpcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IHNob3VsZENvbXBpbGUgKG9wdGlvbmFsKSAgQSBGdW5jdGlvbiB3aGljaCBhbGxvd3MgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlciB0byBkaXNhYmxlIGNvbXBpbGluZyBjZXJ0YWluIGZpbGVzLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCB0YWtlcyBhIGZ1bGx5LXF1YWxpZmllZCBwYXRoIHRvIGEgZmlsZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHNob3VsZCByZXR1cm4gYSBCb29sZWFuLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgQ29tcGxldGlvbi5cbiAgICovXG4gIGFzeW5jIGNvbXBpbGVBbGwocm9vdERpcmVjdG9yeSwgc2hvdWxkQ29tcGlsZT1udWxsKSB7XG4gICAgbGV0IHNob3VsZCA9IHNob3VsZENvbXBpbGUgfHwgZnVuY3Rpb24oKSB7cmV0dXJuIHRydWU7fTtcblxuICAgIGF3YWl0IGZvckFsbEZpbGVzKHJvb3REaXJlY3RvcnksIChmKSA9PiB7XG4gICAgICBpZiAoIXNob3VsZChmKSkgcmV0dXJuO1xuXG4gICAgICBkKGBDb21waWxpbmcgJHtmfWApO1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZShmLCB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLypcbiAgICogU3luYyBNZXRob2RzXG4gICAqL1xuXG4gIGNvbXBpbGVTeW5jKGZpbGVQYXRoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlYWRPbmx5TW9kZSA/IHRoaXMuY29tcGlsZVJlYWRPbmx5U3luYyhmaWxlUGF0aCkgOiB0aGlzLmZ1bGxDb21waWxlU3luYyhmaWxlUGF0aCkpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZVJlYWRvbmx5RnJvbUNvbmZpZ3VyYXRpb25TeW5jKHJvb3RDYWNoZURpciwgYXBwUm9vdCwgZmFsbGJhY2tDb21waWxlcj1udWxsKSB7XG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbihyb290Q2FjaGVEaXIsICdjb21waWxlci1pbmZvLmpzb24uZ3onKTtcbiAgICBsZXQgYnVmID0gZnMucmVhZEZpbGVTeW5jKHRhcmdldCk7XG4gICAgbGV0IGluZm8gPSBKU09OLnBhcnNlKHpsaWIuZ3VuemlwU3luYyhidWYpKTtcblxuICAgIGxldCBmaWxlQ2hhbmdlQ2FjaGUgPSBGaWxlQ2hhbmdlZENhY2hlLmxvYWRGcm9tRGF0YShpbmZvLmZpbGVDaGFuZ2VDYWNoZSwgYXBwUm9vdCwgdHJ1ZSk7XG5cbiAgICBsZXQgY29tcGlsZXJzID0gT2JqZWN0LmtleXMoaW5mby5jb21waWxlcnMpLnJlZHVjZSgoYWNjLCB4KSA9PiB7XG4gICAgICBsZXQgY3VyID0gaW5mby5jb21waWxlcnNbeF07XG4gICAgICBhY2NbeF0gPSBuZXcgUmVhZE9ubHlDb21waWxlcihjdXIubmFtZSwgY3VyLmNvbXBpbGVyVmVyc2lvbiwgY3VyLmNvbXBpbGVyT3B0aW9ucywgY3VyLmlucHV0TWltZVR5cGVzKTtcblxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4gbmV3IENvbXBpbGVySG9zdChyb290Q2FjaGVEaXIsIGNvbXBpbGVycywgZmlsZUNoYW5nZUNhY2hlLCB0cnVlLCBmYWxsYmFja0NvbXBpbGVyKTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVGcm9tQ29uZmlndXJhdGlvblN5bmMocm9vdENhY2hlRGlyLCBhcHBSb290LCBjb21waWxlcnNCeU1pbWVUeXBlLCBmYWxsYmFja0NvbXBpbGVyPW51bGwpIHtcbiAgICBsZXQgdGFyZ2V0ID0gcGF0aC5qb2luKHJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xuICAgIGxldCBidWYgPSBmcy5yZWFkRmlsZVN5bmModGFyZ2V0KTtcbiAgICBsZXQgaW5mbyA9IEpTT04ucGFyc2UoemxpYi5ndW56aXBTeW5jKGJ1ZikpO1xuXG4gICAgbGV0IGZpbGVDaGFuZ2VDYWNoZSA9IEZpbGVDaGFuZ2VkQ2FjaGUubG9hZEZyb21EYXRhKGluZm8uZmlsZUNoYW5nZUNhY2hlLCBhcHBSb290LCBmYWxzZSk7XG5cbiAgICBPYmplY3Qua2V5cyhpbmZvLmNvbXBpbGVycykuZm9yRWFjaCgoeCkgPT4ge1xuICAgICAgbGV0IGN1ciA9IGluZm8uY29tcGlsZXJzW3hdO1xuICAgICAgY29tcGlsZXJzQnlNaW1lVHlwZVt4XS5jb21waWxlck9wdGlvbnMgPSBjdXIuY29tcGlsZXJPcHRpb25zO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBDb21waWxlckhvc3Qocm9vdENhY2hlRGlyLCBjb21waWxlcnNCeU1pbWVUeXBlLCBmaWxlQ2hhbmdlQ2FjaGUsIGZhbHNlLCBmYWxsYmFja0NvbXBpbGVyKTtcbiAgfVxuXG4gIHNhdmVDb25maWd1cmF0aW9uU3luYygpIHtcbiAgICBsZXQgc2VyaWFsaXplZENvbXBpbGVyT3B0cyA9IE9iamVjdC5rZXlzKHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZSkucmVkdWNlKChhY2MsIHgpID0+IHtcbiAgICAgIGxldCBjb21waWxlciA9IHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVt4XTtcbiAgICAgIGxldCBLbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21waWxlcikuY29uc3RydWN0b3I7XG5cbiAgICAgIGxldCB2YWwgPSB7XG4gICAgICAgIG5hbWU6IEtsYXNzLm5hbWUsXG4gICAgICAgIGlucHV0TWltZVR5cGVzOiBLbGFzcy5nZXRJbnB1dE1pbWVUeXBlcygpLFxuICAgICAgICBjb21waWxlck9wdGlvbnM6IGNvbXBpbGVyLmNvbXBpbGVyT3B0aW9ucyxcbiAgICAgICAgY29tcGlsZXJWZXJzaW9uOiBjb21waWxlci5nZXRDb21waWxlclZlcnNpb24oKVxuICAgICAgfTtcblxuICAgICAgYWNjW3hdID0gdmFsO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG5cbiAgICBsZXQgaW5mbyA9IHtcbiAgICAgIGZpbGVDaGFuZ2VDYWNoZTogdGhpcy5maWxlQ2hhbmdlQ2FjaGUuZ2V0U2F2ZWREYXRhKCksXG4gICAgICBjb21waWxlcnM6IHNlcmlhbGl6ZWRDb21waWxlck9wdHNcbiAgICB9O1xuXG4gICAgbGV0IHRhcmdldCA9IHBhdGguam9pbih0aGlzLnJvb3RDYWNoZURpciwgJ2NvbXBpbGVyLWluZm8uanNvbi5neicpO1xuICAgIGxldCBidWYgPSB6bGliLmd6aXBTeW5jKG5ldyBCdWZmZXIoSlNPTi5zdHJpbmdpZnkoaW5mbykpKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKHRhcmdldCwgYnVmKTtcbiAgfVxuXG4gIGNvbXBpbGVSZWFkT25seVN5bmMoZmlsZVBhdGgpIHtcbiAgICAvLyBXZSBndWFyYW50ZWUgdGhhdCBub2RlX21vZHVsZXMgYXJlIGFsd2F5cyBzaGlwcGVkIGRpcmVjdGx5XG4gICAgbGV0IHR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcbiAgICBpZiAoRmlsZUNoYW5nZWRDYWNoZS5pc0luTm9kZU1vZHVsZXMoZmlsZVBhdGgpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW1lVHlwZTogdHlwZSB8fCAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXG4gICAgICAgIGNvZGU6IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgaGFzaEluZm8gPSB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aFN5bmMoZmlsZVBhdGgpO1xuXG4gICAgLy8gV2UgZ3VhcmFudGVlIHRoYXQgbm9kZV9tb2R1bGVzIGFyZSBhbHdheXMgc2hpcHBlZCBkaXJlY3RseVxuICAgIGlmIChoYXNoSW5mby5pc0luTm9kZU1vZHVsZXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbWVUeXBlOiB0eXBlLFxuICAgICAgICBjb2RlOiBoYXNoSW5mby5zb3VyY2VDb2RlIHx8IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBOQjogSGVyZSwgd2UncmUgYmFzaWNhbGx5IG9ubHkgdXNpbmcgdGhlIGNvbXBpbGVyIGhlcmUgdG8gZmluZFxuICAgIC8vIHRoZSBhcHByb3ByaWF0ZSBDb21waWxlQ2FjaGVcbiAgICBsZXQgY29tcGlsZXIgPSBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pID9cbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcbiAgICAgIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVt0eXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcblxuICAgIGlmICghY29tcGlsZXIpIHtcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5mYWxsYmFja0NvbXBpbGVyO1xuXG4gICAgICBsZXQgeyBjb2RlLCBiaW5hcnlEYXRhLCBtaW1lVHlwZSB9ID0gY29tcGlsZXIuZ2V0U3luYyhmaWxlUGF0aCk7XG4gICAgICByZXR1cm4geyBjb2RlOiBjb2RlIHx8IGJpbmFyeURhdGEsIG1pbWVUeXBlIH07XG4gICAgfVxuXG4gICAgbGV0IGNhY2hlID0gdGhpcy5jYWNoZXNGb3JDb21waWxlcnMuZ2V0KGNvbXBpbGVyKTtcbiAgICBsZXQge2NvZGUsIGJpbmFyeURhdGEsIG1pbWVUeXBlfSA9IGNhY2hlLmdldFN5bmMoZmlsZVBhdGgpO1xuXG4gICAgY29kZSA9IGNvZGUgfHwgYmluYXJ5RGF0YTtcbiAgICBpZiAoIWNvZGUgfHwgIW1pbWVUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFza2VkIHRvIGNvbXBpbGUgJHtmaWxlUGF0aH0gaW4gcHJvZHVjdGlvbiwgaXMgdGhpcyBmaWxlIG5vdCBwcmVjb21waWxlZD9gKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBjb2RlLCBtaW1lVHlwZSB9O1xuICB9XG5cbiAgZnVsbENvbXBpbGVTeW5jKGZpbGVQYXRoKSB7XG4gICAgZChgQ29tcGlsaW5nICR7ZmlsZVBhdGh9YCk7XG5cbiAgICBsZXQgaGFzaEluZm8gPSB0aGlzLmZpbGVDaGFuZ2VDYWNoZS5nZXRIYXNoRm9yUGF0aFN5bmMoZmlsZVBhdGgpO1xuICAgIGxldCB0eXBlID0gbWltZVR5cGVzLmxvb2t1cChmaWxlUGF0aCk7XG5cbiAgICBpZiAoaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzKSB7XG4gICAgICBsZXQgY29kZSA9IGhhc2hJbmZvLnNvdXJjZUNvZGUgfHwgZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgICAgcmV0dXJuIHsgY29kZSwgbWltZVR5cGU6IHR5cGUgfTtcbiAgICB9XG5cbiAgICBsZXQgY29tcGlsZXIgPSBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pID9cbiAgICAgIHRoaXMuZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIDpcbiAgICAgIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZVt0eXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcblxuICAgIGlmICghY29tcGlsZXIpIHtcbiAgICAgIGQoYEZhbGxpbmcgYmFjayB0byBwYXNzdGhyb3VnaCBjb21waWxlciBmb3IgJHtmaWxlUGF0aH1gKTtcbiAgICAgIGNvbXBpbGVyID0gdGhpcy5mYWxsYmFja0NvbXBpbGVyO1xuICAgIH1cblxuICAgIGlmICghY29tcGlsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBhIGNvbXBpbGVyIGZvciAke2ZpbGVQYXRofWApO1xuICAgIH1cblxuICAgIGxldCBjYWNoZSA9IHRoaXMuY2FjaGVzRm9yQ29tcGlsZXJzLmdldChjb21waWxlcik7XG4gICAgcmV0dXJuIGNhY2hlLmdldE9yRmV0Y2hTeW5jKFxuICAgICAgZmlsZVBhdGgsXG4gICAgICAoZmlsZVBhdGgsIGhhc2hJbmZvKSA9PiB0aGlzLmNvbXBpbGVVbmNhY2hlZFN5bmMoZmlsZVBhdGgsIGhhc2hJbmZvLCBjb21waWxlcikpO1xuICB9XG5cbiAgY29tcGlsZVVuY2FjaGVkU3luYyhmaWxlUGF0aCwgaGFzaEluZm8sIGNvbXBpbGVyKSB7XG4gICAgbGV0IGlucHV0TWltZVR5cGUgPSBtaW1lVHlwZXMubG9va3VwKGZpbGVQYXRoKTtcblxuICAgIGlmIChoYXNoSW5mby5pc0ZpbGVCaW5hcnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJpbmFyeURhdGE6IGhhc2hJbmZvLmJpbmFyeURhdGEgfHwgZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoKSxcbiAgICAgICAgbWltZVR5cGU6IGlucHV0TWltZVR5cGUsXG4gICAgICAgIGRlcGVuZGVudEZpbGVzOiBbXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgY3R4ID0ge307XG4gICAgbGV0IGNvZGUgPSBoYXNoSW5mby5zb3VyY2VDb2RlIHx8IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgJ3V0ZjgnKTtcblxuICAgIGlmICghKGNvbXBpbGVyLnNob3VsZENvbXBpbGVGaWxlU3luYyhjb2RlLCBjdHgpKSkge1xuICAgICAgZChgQ29tcGlsZXIgcmV0dXJuZWQgZmFsc2UgZm9yIHNob3VsZENvbXBpbGVGaWxlOiAke2ZpbGVQYXRofWApO1xuICAgICAgcmV0dXJuIHsgY29kZSwgbWltZVR5cGU6IG1pbWVUeXBlcy5sb29rdXAoZmlsZVBhdGgpLCBkZXBlbmRlbnRGaWxlczogW10gfTtcbiAgICB9XG5cbiAgICBsZXQgZGVwZW5kZW50RmlsZXMgPSBjb21waWxlci5kZXRlcm1pbmVEZXBlbmRlbnRGaWxlc1N5bmMoY29kZSwgZmlsZVBhdGgsIGN0eCk7XG5cbiAgICBsZXQgcmVzdWx0ID0gY29tcGlsZXIuY29tcGlsZVN5bmMoY29kZSwgZmlsZVBhdGgsIGN0eCk7XG5cbiAgICBsZXQgc2hvdWxkSW5saW5lSHRtbGlmeSA9XG4gICAgICBpbnB1dE1pbWVUeXBlICE9PSAndGV4dC9odG1sJyAmJlxuICAgICAgcmVzdWx0Lm1pbWVUeXBlID09PSAndGV4dC9odG1sJztcblxuICAgIGxldCBpc1Bhc3N0aHJvdWdoID1cbiAgICAgIHJlc3VsdC5taW1lVHlwZSA9PT0gJ3RleHQvcGxhaW4nIHx8XG4gICAgICAhcmVzdWx0Lm1pbWVUeXBlIHx8XG4gICAgICBDb21waWxlckhvc3Quc2hvdWxkUGFzc3Rocm91Z2goaGFzaEluZm8pO1xuXG4gICAgaWYgKChmaW5hbEZvcm1zW3Jlc3VsdC5taW1lVHlwZV0gJiYgIXNob3VsZElubGluZUh0bWxpZnkpIHx8IGlzUGFzc3Rocm91Z2gpIHtcbiAgICAgIC8vIEdvdCBzb21ldGhpbmcgd2UgY2FuIHVzZSBpbi1icm93c2VyLCBsZXQncyByZXR1cm4gaXRcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlc3VsdCwge2RlcGVuZGVudEZpbGVzfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQoYFJlY3Vyc2l2ZWx5IGNvbXBpbGluZyByZXN1bHQgb2YgJHtmaWxlUGF0aH0gd2l0aCBub24tZmluYWwgTUlNRSB0eXBlICR7cmVzdWx0Lm1pbWVUeXBlfSwgaW5wdXQgd2FzICR7aW5wdXRNaW1lVHlwZX1gKTtcblxuICAgICAgaGFzaEluZm8gPSBPYmplY3QuYXNzaWduKHsgc291cmNlQ29kZTogcmVzdWx0LmNvZGUsIG1pbWVUeXBlOiByZXN1bHQubWltZVR5cGUgfSwgaGFzaEluZm8pO1xuICAgICAgY29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyc0J5TWltZVR5cGVbcmVzdWx0Lm1pbWVUeXBlIHx8ICdfX2xvbG5vdGhlcmUnXTtcblxuICAgICAgaWYgKCFjb21waWxlcikge1xuICAgICAgICBkKGBSZWN1cnNpdmUgY29tcGlsZSBmYWlsZWQgLSBpbnRlcm1lZGlhdGUgcmVzdWx0OiAke0pTT04uc3RyaW5naWZ5KHJlc3VsdCl9YCk7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21waWxpbmcgJHtmaWxlUGF0aH0gcmVzdWx0ZWQgaW4gYSBNSU1FIHR5cGUgb2YgJHtyZXN1bHQubWltZVR5cGV9LCB3aGljaCB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGVgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZVVuY2FjaGVkU3luYyhcbiAgICAgICAgYCR7ZmlsZVBhdGh9LiR7bWltZVR5cGVzLmV4dGVuc2lvbihyZXN1bHQubWltZVR5cGUgfHwgJ3R4dCcpfWAsXG4gICAgICAgIGhhc2hJbmZvLCBjb21waWxlcik7XG4gICAgfVxuICB9XG5cbiAgY29tcGlsZUFsbFN5bmMocm9vdERpcmVjdG9yeSwgc2hvdWxkQ29tcGlsZT1udWxsKSB7XG4gICAgbGV0IHNob3VsZCA9IHNob3VsZENvbXBpbGUgfHwgZnVuY3Rpb24oKSB7cmV0dXJuIHRydWU7fTtcblxuICAgIGZvckFsbEZpbGVzU3luYyhyb290RGlyZWN0b3J5LCAoZikgPT4ge1xuICAgICAgaWYgKCFzaG91bGQoZikpIHJldHVybjtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVTeW5jKGYsIHRoaXMuY29tcGlsZXJzQnlNaW1lVHlwZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKlxuICAgKiBPdGhlciBzdHVmZlxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXNzdGhyb3VnaCBjb21waWxlclxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGFzc3Rocm91Z2hDb21waWxlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb21waWxlcnNCeU1pbWVUeXBlWyd0ZXh0L3BsYWluJ107XG4gIH1cblxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGV2ZW4gdHJ5IHRvIGNvbXBpbGUgdGhlIGNvbnRlbnQuIE5vdGUgdGhhdCBpblxuICAgKiBzb21lIGNhc2VzLCBjb250ZW50IHdpbGwgc3RpbGwgYmUgaW4gY2FjaGUgZXZlbiBpZiB0aGlzIHJldHVybnMgdHJ1ZSwgYW5kXG4gICAqIGluIG90aGVyIGNhc2VzIChpc0luTm9kZU1vZHVsZXMpLCB3ZSdsbCBrbm93IGV4cGxpY2l0bHkgdG8gbm90IGV2ZW4gYm90aGVyXG4gICAqIGxvb2tpbmcgaW4gdGhlIGNhY2hlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIHNob3VsZFBhc3N0aHJvdWdoKGhhc2hJbmZvKSB7XG4gICAgcmV0dXJuIGhhc2hJbmZvLmlzTWluaWZpZWQgfHwgaGFzaEluZm8uaXNJbk5vZGVNb2R1bGVzIHx8IGhhc2hJbmZvLmhhc1NvdXJjZU1hcCB8fCBoYXNoSW5mby5pc0ZpbGVCaW5hcnk7XG4gIH1cbn1cbiJdfQ==